import { shaderMaterial } from '@react-three/drei';
import glsl from 'babel-plugin-glsl/macro';

const PaintWithMathShaderMaterial = shaderMaterial(
  /*
  ----------Uniforms Section---------------------------------------
  */
  {
    uResolutionX: 0,
    uResolutionY: 0,
    /*
    think of this as a kind of "offset"; offsetting is based on two operations: "+" or "-" !!!; somethig that can slightly changes the position "over the time" / constantly;
    */
    uTime: 0,
  },
  /*
  ----------Vertex Shader Section-----------------------------------
  */
  glsl`
  /*
  extract "atributes" from <ContainerAnswerYes> i.e. from Java Script;
  */
  /*
  extract uniforms from <ContainerAnswerYes>
  */
  uniform float uTime;
  /*
  create / declare "varying" for "Fragment Shader sake";
  */
  varying vec2 vUv;
  varying vec2 vScreenCoordinates;
  
  /*
  Main Function Section;
  */
  void main (){
      vec4 worldSpace = modelMatrix * vec4(position, 1.);
      vec4 viewSpace = viewMatrix * worldSpace;
      vec4 clipSpace = projectionMatrix * viewSpace;
      gl_Position = clipSpace;
      /*
      assign verying for "Fragment Shader sake";
      we do our best to create great-dynamically-changing "elevation value", so wy don't we pass it to the "Fragment Shader"
      */
        vUv = uv;
      /*
      What is "vScreenCoordinates"?
      This is the way we get "screen coordinates" within Vertex Shader (remember that shader is just a small application with some default outputs)... these coordinates are given for free!!! just use them!... using "gl_Position.w" a normalized version is created...yet I don't know what that ".w" is... 
      so wa are talking about "screen space" generated by all this matrices that take part in final result of gl_Position!!!
      moreover, it allowes to achieve some effects without 'postprocessing'
      */
        vScreenCoordinates = gl_Position.xy/gl_Position.w;

  }
  /*
  ----------Fragment Shader Section----------------------------------------
  */
  `,
  glsl`
  #define NUM_PARTICLES 20.
    /*
  extract varyings from Vertex Shader;
  */
  varying vec2 vUv;
  varying vec2 vScreenCoordinates;

  /*
  extract uniforms from <ContainerAnswerYes>
  */
  uniform float uTime;
  uniform float uResolutionX;
  uniform float uResolutionY;

  /*
  Main Function Section;
  */
  void main (){
      /*
       initially "uVu-coordinate-system" spans from 0 to 1
       imagine two type of operations:
       <1> scaling => "*" or "\"
       <2> offsetting => "+" or "-" 
       now our "uVu-coordinate-system" spans from -1 to 1 with (0,0) in center center of the picture / plane
      */
      // vec2 uv = vUv * 2. - 1. ; // uv *= vec2(2.); uv -= vec2(1.); 
      vec2 uv = vUv - .5 ; //
      /*
       color for final function gl_FragColor; 
      */
      vec3 baseColor = vec3(0.,.5,0.);
      /*
       ..............................................................
       resource: https://www.youtube.com/watch?v=0ifChJ0nJfM
      */
     
    
    gl_FragColor = vec4(vec3(baseColor), 1.);

  }
  `
);

export { PaintWithMathShaderMaterial };
