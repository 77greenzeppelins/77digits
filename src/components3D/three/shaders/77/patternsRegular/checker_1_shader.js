import { shaderMaterial } from '@react-three/drei';
import glsl from 'babel-plugin-glsl/macro';
import * as THREE from 'three';

const Checker_1_ShaderMaterial = shaderMaterial(
  /*
   _____Uniforms
 */
  {
    uColor: new THREE.Color([1.0, 0.0, 1.0]),
    uTime: 0.0,
    // uDraggedX: 0.0
    uResolutionX: 0.0,
    uResolutionY: 0.0
  },

  /*
   _____Vertex Shader
 */

  glsl`

  varying vec2 vUv;
  varying vec3 vPosition;
  varying vec2 vScreenCoordinates;
  varying vec3 vNormal; 

  
  void main(){
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);

    //___
    vUv = uv;
    vPosition = position;
    vNormal = normal; 
    /*
    What is "vScreenCoordinates"?
    This is the way we get "screen coordinates" within Vertex Shader (remember that shader is just a small application with some default outputs)... these coordinates are given for free!!! just use them!... using "gl_Position.w" a normalized version is created...yet I don't know what that ".w" is... 
    so wa are talking about "screen space" generated by all this matrices that take part in final result of gl_Position!!!
    moreover, it allowes to achieve some effects without 'postprocessing'
    */
    vScreenCoordinates = gl_Position.xy/gl_Position.w;
  }
  
  `,

  /*
   _____Fragment Shader
 */

  glsl`

  #define PI 3,141592 653589 793238 462643 383279;

  varying vec2 vUv;
  varying vec3 vPosition;
  varying vec2 vScreenCoordinates;
  varying vec3 vNormal; 

  uniform float uTime;
  // uniform float uDraggedX;

  //___taken from Book of Shaders
  float random(vec2 coordinates){
    return fract(sin(dot(coordinates.xy, vec2(12.9898, 78.233)))*43758.5453123);
  }

  void main (){
    //
    float multiGradient = 0.;
      /*
      _____Basic coloring of shader; no need to comments this line as only the one is red
      */
      float yVariation = floor((vUv.y + uTime) * 10.);
      float xVariation = floor((vUv.x + uTime) * 1.);
    //   float xyVariation = floor((vUv.x + uTime*0.5) * 8.) - floor((vUv.y + uTime*0.5) * 8.);

      gl_FragColor = vec4(mod(xVariation, 3.),mod(xVariation, 1.),mod(xVariation, 1.),1.);
    //   gl_FragColor = vec4(vec3(1.),1.);
      // gl_FragColor = vec4(vScreenCoordinates, 1.,1.);
      // gl_FragColor = vec4(vPosition,1.);

      //___patern: imagin that "initial plane" is divided into 10 horizontal lines; and the bottom one line is gradient, rest are white because their value is above 1.
      float colorizator = vUv.y *10.;

      //___patern: 10 vertical lines with gradient; it's 10 within whole "plane", so on "seven shape" we can see less then 10...how it werks? => when you reach "1" start from "0"
      colorizator = mod(vUv.x *20., 1.);
      // colorizator = mod(vUv.x, .5);

      //___patern: if (colorizator =mod(vUv.x *20., 1.)) {10 vertical lines, or 20 white/black}
      colorizator = step(0.9, colorizator);
      //___patern animated: reveals "7" from top to bottom
      // colorizator = step(1., vUv.y+ uTime * 0.5);

      //___patern: grid
      colorizator = step(0.9, mod(vUv.x*20., 1.));
      colorizator += step(0.9, mod(vUv.y*20., 1.));

      //___patern: pointed grid
      colorizator = step(0.85, mod(vUv.x*30., 1.));
      colorizator *= step(0.85, mod(vUv.y*30., 1.));

      gl_FragColor = vec4(vec3(colorizator),1.);

     //___patern group2: complex shape mutipicated; create two "separtated" bars and then play with them...
      float barX = step(0.4, mod(vUv.x*15., 1.));
      barX *= step(0.8, mod(vUv.y*15., 1.));

      float barY = step(0.8, mod(vUv.x*15., 1.));
      barY *= step(0.4, mod(vUv.y*15., 1.));

      float finalShape = barX + barY;

      //___patern: complex mutipicated shape +  offset of  vUv.x value; and we've drawn "plus signs"
       barX = step(0.4, mod(vUv.x*15., 1.));
      barX *= step(0.8, mod(vUv.y*15.+ 0.2, 1.));

       barY = step(0.8, mod(vUv.x*15.+ 0.2, 1.));
      barY *= step(0.4, mod(vUv.y*15., 1.));

       finalShape = barX + barY;
      //  float alpha = step(0.,finalShape);
      gl_FragColor = vec4(vec3(finalShape),1.);

      //___patern group3; offseting 'vUv.x' by '-0.5' we get new value on x-axis so that: 0=-0.5, 0.5=0, 1=0.5; usin abs() we get only positive values =>result is horizontal gradient black in center and grey near left and right border... 
       float someGradient = abs(vUv.x -0.5);
      gl_FragColor = vec4(vec3(someGradient),1.);

      //___patern
      someGradient = min(abs(vUv.x -0.5), abs(vUv.y -0.5));
      gl_FragColor = vec4(vec3(someGradient),1.);

      someGradient = max(abs(vUv.x -0.5), abs(vUv.y -0.5));
      gl_FragColor = vec4(vec3(someGradient),1.);

      //___patern; geometrical abstraction; 
      float someMalewicz = 1. - step(0.1, max(abs(vUv.x -0.5), abs(vUv.y -0.5)));
      gl_FragColor = vec4(vec3(someMalewicz),someMalewicz);
      
      //___patern gradiented grid; 
       multiGradient = round(vUv.x * 20.)/20. + 0.15;
      multiGradient *= round(vUv.y * 20.)/20. + 0.15;
      gl_FragColor = vec4(vec3(multiGradient),someMalewicz);

      //___patern noise!!!;
      float noise = random(vUv);
      gl_FragColor = vec4(vec3(noise),someMalewicz);

      //___patern with custom 'grid coordinates'
      vec2 gridUv = vec2(round(vUv.x * 20.)/20. + 0.15, round(vUv.y * 20.)/20. + 0.15);
      noise = random(gridUv);
      gl_FragColor = vec4(vec3(noise),someMalewicz);

      //___patern group 4; 
      colorizator = length(vUv);
      gl_FragColor = vec4(vec3(colorizator),someMalewicz);

      //___patern: gradiented circle that cen be dark / light in the center => just manipulate value before minus sign...
      colorizator = 0.8 - distance(vUv, vec2(0.5));
      gl_FragColor = vec4(vec3(colorizator),someMalewicz);

      //___patern: special one to get small, very bright point
      colorizator = 0.008 / distance(vUv, vec2(0.5)) + 0.1;
      gl_FragColor = vec4(vec3(colorizator),someMalewicz);


//___patern gradiented grid;
      // vec2 uv = 2. * vUv - 1.; 
      // multiGradient = round(uv.x * 20.)/20. + 0.1;
      // multiGradient *= round(uv.y * 20.)/20. + 0.1;
      // gl_FragColor = vec4(vec3(multiGradient),someMalewicz);

//___patern with colors
      // vec3 darkColor = vec3(0.1 + sin(uTime*0.5) ,0.11,0.47);
      // vec3 lightColor = vec3(0.15,0.82,0.81);
      // 
      vec3 darkColor = vec3(0., abs(0. *3.), 0.);
      vec3 lightColor = vec3(1.,abs(1. *2.),1.);
      vec3 colorMixer = mix(darkColor,lightColor, multiGradient);
      gl_FragColor = vec4(colorMixer,someMalewicz);
  }
  
  `
);
export { Checker_1_ShaderMaterial };
