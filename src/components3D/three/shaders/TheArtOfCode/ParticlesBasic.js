import * as THREE from 'three';
import { shaderMaterial } from '@react-three/drei';
import glsl from 'babel-plugin-glsl/macro';
/*

*/
// import {NoiseMaker} from './BasicNoise';

const ParticlesBasicShaderMaterial = shaderMaterial(
  /*
  ----------Uniforms Section---------------------------------------
  */
  {
    uResolutionX: 0,
    uResolutionY: 0,
    /*
    think of this as a kind of "offset"; offsetting is based on two operations: "+" or "-" !!!; somethig that can slightly changes the position "over the time" / constantly;
    */
    uTime: 0,
    uSwitcher: 0,
  },
  /*
  ----------Vertex Shader Section-----------------------------------
  */
  glsl`
  /*
  extract "atributes" from <ContainerAnswerYes> i.e. from Java Script;
  */
  /*
  extract uniforms from <ContainerAnswerYes>
  */
  uniform float uTime;
  /*
  create / declare "varying" for "Fragment Shader sake";
  */
  varying vec2 vUv;
  varying vec2 vScreenCoordinates;

  
  
  /*
  Main Function Section;
  */
  void main (){
      vec4 worldSpace = modelMatrix * vec4(position, 1.);
      vec4 viewSpace = viewMatrix * worldSpace;
      vec4 clipSpace = projectionMatrix * viewSpace;
      gl_Position = clipSpace;
      /*
      assign verying for "Fragment Shader sake";
      we do our best to create great-dynamically-changing "elevation value", so wy don't we pass it to the "Fragment Shader"
      */
        vUv = uv;
      /*
      What is "vScreenCoordinates"?
      This is the way we get "screen coordinates" within Vertex Shader (remember that shader is just a small application with some default outputs)... these coordinates are given for free!!! just use them!... using "gl_Position.w" a normalized version is created...yet I don't know what that ".w" is... 
      so wa are talking about "screen space" generated by all this matrices that take part in final result of gl_Position!!!
      moreover, it allowes to achieve some effects without 'postprocessing'
      */
        vScreenCoordinates = gl_Position.xy/gl_Position.w;

  }
  /*
  ----------Fragment Shader Section-----------------------------------
  */
  `,
  glsl`
  #define NUM_PARTICLES 20.
    /*
  extract varyings from Vertex Shader;
  */
  varying vec2 vUv;
  /*
  extract uniforms from <ContainerAnswerYes>
  */
  uniform float uTime;
  uniform float uResolutionX;
  uniform float uResolutionY;
  // uniform int uSwitcher;
  uniform bool uSwitcher;

  /*
  Functions
  "p" point from which we gona calculate distance;
  "a" line segment start point;
  "b" line segment end point;
  "0 & 1" are actually clamps;
  */
  float DistLine(vec2 p, vec2 a, vec2 b){
    vec2 pa = p-a;
    vec2 ba = b-a;
    float t = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);
    return length(pa - ba * t);
  }
  /*
  */
  float LineCreator (vec2 p, vec2 a, vec2 b){
    float d = DistLine(p, a, b);
    float m = smoothstep(.03, .01, d);
    /*
    firt smoothstep() specifies when line should be visible;
    if distance between points is approaching 1.2 line is vanishing; over 1.2 is invisible i.e have value of 0;
    if is approaching 0.8 becomes more visible; les then 0.8 means "I'm white"! 
    second smoothstep() specifies when line's thickness;
    */
   m *= smoothstep(1.2, .8, length(a-b))* .5 + smoothstep(.05, .03, abs(length(a-b)- .75) );
    return m;
  }
  /*
  Random numbers generator
  we can do this using sin() that is easy & fast yet autor suggests thera are some cross-platforms problems;
  */
  float RandomFloat(vec2 p){
    /*
    "p" here is between 0<>1;
    */
    p = fract(p * vec2(233.34, 851.73));
    p += dot(p, p + 23.45);
    return fract(p.x * p.y);
  }
  /*
  Random vectors generator i.e random position generator
  */
 vec2 RandomVector(vec2 p){
    float n = RandomFloat(p);
    return vec2(n, RandomFloat(p+n));
 }
 /*
 */
 vec2 GetStaticPosition (vec2 id){
   return RandomVector(id) - .5;
 }
 vec2 GetAnimatedPosition (vec2 id, vec2 offset){
    // vec2 someNoise = RandomVector(id + offset);
    // float x = sin(uTime * someNoise.x) + offset.x ;
    // float y = cos(uTime * someNoise.y) + offset.y ;
    // return vec2(x,y) * .4;
    vec2 n = RandomVector(id + offset) * uTime;
    return offset + sin(n) * .4;
}

  /*
  Main Function Section;
  */
  void main (){
      /*
      ................................................................
      resource: 
      /*
       initially "uVu-coordinate-system" spans from 0 to 1
       imagine two type of operations:
       <1> scaling => "*" or "\"
       <2> offsetting => "+" or "-" 
       formula "vUv * 2. - 1." returns  "uVu-coordinate-system" that spans from -1 to 1 with (0,0) in center center of the picture / plane
      */
      /*
      Basic coordinateSyetem for 
      */
      // vec2 myCoordSystem = vUv * 1. - .5;
      vec2 myCoordSystem = vUv * 2. - 1.;
      myCoordSystem *= 10.;
      /*
      Responsive coordinateSyetem for 
      resource: https://www.youtube.com/watch?v=YaCne65rXEE
      */
      vec2 responsiveCoordSystem = (gl_FragCoord.xy * 2.0 - vec2(uResolutionX, uResolutionY)) / min(uResolutionX, uResolutionY);
      /*
      color for final function gl_FragColor; 
      */
      vec4 color = vec4(0.,0.,0.,1.);
      /*
      pulseMaker delivers some effect of pulsing
      used as offsetter nicelly moves/animates pattern from center to "plane frame" and aback (i z powrotem);
      */
      float pulseMaker = sin(uTime);

      /*
      ..............................................................
      resource
      https://www.youtube.com/watch?v=zXsWftRdsvU
      */
      /*
      Basic Values
      */
      float timeSpead = uTime * 2.;
      // myCoordSystem *=10.;
      /*
      Grid Maker
      Initially each cell has 0<>1 coordinate system;
      The way we can create repeated pattern;
      fract(1.53) returns decimal/fractional component i.e. 0.53; 
      "-.5" set (0.0) in center of the cell
      */
      vec2 grid = fract(myCoordSystem) - .5;
      /*
      how to create indices that could identify each cell?
      we need id for each cell; floor(1.53) return integer component of the number i.e. 1.;
      */
      vec2 id = floor(myCoordSystem);  
      /*
      Color Manipulations Section
      */
      /*
      How to draw a point in each cell;
      RandomVector(id) returns random numbers 0<>1;
      with '-.5 we have -0.5<>0.5 coordinate system for each cell
      */
      // vec2 cellValue = GetAnimatedPosition(id);
      // float l = length(grid-cellValue);
      // float point = smoothstep(.1, .04, l);
      /*
      What is "m" ?
      */
      float m = 0.;
      /*
      What is "p" ?
      */
      vec2 p[9];
      /*
      What is "i" ? just index for iteration;
      */
      int i = 0; 
      /*
      What does this loop do?
      */
     for (float y = -1.; y <= 1.; y++ ){
       for (float x = -1.; x <= 1.; x++ ){
         p[i++] = GetAnimatedPosition(id, vec2(x,y));
        //  i++;
       }
     }

     /*
      What does this loop do?
      */
     for(int i=0; i<9; i++){
       m += LineCreator(grid, p[4], p[i]);
       /*
       sparkling section i.e. 
       */
      vec2 j = (p[i] - grid) * 20.;
      // float sparkle = 1./length(j);
      float sparkle = 1./dot(j, j);
      /*
      adding sin() our dots starts blinking
      "fract(p[i].x)* 10." allowes async blinking i.e. not all at the same time; additionally fract() cancel some artefacts i.e without it we can see sells as grey background;
      */
      m += sparkle * (sin(uTime + fract(p[i].x)* 10.)*.5 + .5);
     }
      m += LineCreator(grid, p[1], p[3]);
      m += LineCreator(grid, p[1], p[5]);
      m += LineCreator(grid, p[5], p[7]);
      m += LineCreator(grid, p[7], p[3]);
      /*
      transparency...doesn't work...
      */
       float someMalewicz = 1. - step(0.1, max(abs(myCoordSystem.x -0.5), abs(myCoordSystem.y -0.5)));
      //  float someMalewicz = 1. - step(0.1, max(abs(vUv.x -0.5), abs(vUv.y -0.5)));
      /*
      Color Playground
      */
      /*
       main idea of colors is "cycle throught various colors";
       to do this author creats three "sineVawes" that changes with different speed over course of time;
       sin() with input of vec3 generates vec3; it goes from -1<>1 as usually;
      */
      
      
      if(uSwitcher){
        /*
        This "if statement" is required to turn on / turn off shader that essentially plays role of background for "odlot section" within <ContainerIntroContyent>
        */
       vec3 baseColor = sin(uTime * vec3(.234, .456, .678)) * 0.2 + 0.3;
         color.rgb = vec3(m* baseColor);
         color.a = someMalewicz;
      };
      // color.rgb = vec3(m);
      /*
      how to create red grid lines? just for debugging purpose;
      */
      // if(grid.x > .45 || grid.y > .45) color.r = 1.;
      /*
      Evaluate final color
      */
      gl_FragColor = vec4(vec4(color));
  }
  `
);
export { ParticlesBasicShaderMaterial };

/*
Test of DistLine
*/
// float distLine = DistLine(myCoordSystem, vec2(0), vec2(1));
// color.rgb = vec3(distLine);
// color.rg = vec2(distLine);
// color.b = distLine;
/*
Test of RandomFloat
*/
// float randomFloat = RandomFloat(myCoordSystem);
// color.rgb = vec3(randomFloat);
/*
Test of RandomFloat
*/
//  color.rg = grid;
//  color.b = 0.0;
