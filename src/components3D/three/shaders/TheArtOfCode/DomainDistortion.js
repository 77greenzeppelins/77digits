import { shaderMaterial } from '@react-three/drei';
import glsl from 'babel-plugin-glsl/macro';

const DomainDistortionShaderMaterial = shaderMaterial(
  /*
  ----------Uniforms Section---------------------------------------
  */
  {
    uResolutionX: 0,
    uResolutionY: 0,
    /*
    think of this as a kind of "offset"; offsetting is based on two operations: "+" or "-" !!!; somethig that can slightly changes the position "over the time" / constantly;
    */
    uTime: 0,
  },
  /*
  ----------Vertex Shader Section-----------------------------------
  */
  glsl`
  /*
  extract "atributes" from <ContainerAnswerYes> i.e. from Java Script;
  */
  /*
  extract uniforms from <ContainerAnswerYes>
  */
  uniform float uTime;
  /*
  create / declare "varying" for "Fragment Shader sake";
  */
  varying vec2 vUv;
  varying vec2 vScreenCoordinates;
  
  /*
  Main Function Section;
  */
  void main (){
      vec4 worldSpace = modelMatrix * vec4(position, 1.);
      vec4 viewSpace = viewMatrix * worldSpace;
      vec4 clipSpace = projectionMatrix * viewSpace;
      gl_Position = clipSpace;
      /*
      assign verying for "Fragment Shader sake";
      we do our best to create great-dynamically-changing "elevation value", so wy don't we pass it to the "Fragment Shader"
      */
        vUv = uv;
      /*
      What is "vScreenCoordinates"?
      This is the way we get "screen coordinates" within Vertex Shader (remember that shader is just a small application with some default outputs)... these coordinates are given for free!!! just use them!... using "gl_Position.w" a normalized version is created...yet I don't know what that ".w" is... 
      so wa are talking about "screen space" generated by all this matrices that take part in final result of gl_Position!!!
      moreover, it allowes to achieve some effects without 'postprocessing'
      */
        vScreenCoordinates = gl_Position.xy/gl_Position.w;

  }
  /*
  ----------Fragment Shader Section----------------------------------------
  */
  `,
  glsl`
  #define NUM_PARTICLES 20.
    /*
  extract varyings from Vertex Shader;
  */
  varying vec2 vUv;
  varying vec2 vScreenCoordinates;

  /*
  extract uniforms from <ContainerAnswerYes>
  */
  uniform float uTime;
  uniform float uResolutionX;
  uniform float uResolutionY;

  /*
  Function that draws circle
  */
 float DrawCircle (vec2 uv, vec2 originPointSetter, float radious, float blur){
      float d = length(uv - originPointSetter);
      float circle = smoothstep(radious, radious - blur, d);
      return circle;
 }
  /*
  Function that draws rectangle 
  */
 float DrawRectangle (vec2 uv, float width, float height, float blur){
     float shapeMask = smoothstep(width, width - blur,  uv.x);
     shapeMask *= smoothstep(- width,  blur - width,  uv.x);
     shapeMask *= smoothstep(height, height-blur,  uv.y);
     shapeMask *= smoothstep(-height, blur-height,  uv.y);
     return shapeMask;
 }
 float DrawQuadrangle (vec2 uv, float width, float height, float blur, float widthMod, float heightMode){
     float shapeMask = smoothstep(width, width - blur,  uv.x);
     shapeMask *= smoothstep(- width,  blur - width,  uv.x);
     shapeMask *= smoothstep(height, height-blur,  uv.y);
     shapeMask *= smoothstep(-height, blur-height,  uv.y);
     return shapeMask;
 }
 /*
 if (coordValue === a) return 0;
 if (coordValue === b) return 1;
 if(coordValue is half between a & b) return 0.5;
it actually normalize value of time to range 0<>1; ???
 */
float remap01 (float a, float b,  float coordValue){
    return  (coordValue - a) / (b - a);
}
/*
 if (coordValue === a) return outA;
 if (coordValue === b) return outB;
 if(coordValue is half between a & b) return half between outA & outB;
 */
float remap (float a, float b, float outA, float outB, float coordValue){
   return remap01(a, b, coordValue) * (outB - outA) + outA;

}

  /*
  Main Function Section;
  */
  void main (){
      /*
      ................................................................
      resource: 
      /*
       initially "uVu-coordinate-system" spans from 0 to 1
       imagine two type of operations:
       <1> scaling => "*" or "\"
       <2> offsetting => "+" or "-" 
       now our "uVu-coordinate-system" spans from -1 to 1 with (0,0) in center center of the picture / plane
      */
      vec2 uv = vUv * 2. - 1. ; // uv *= vec2(2.); uv -= vec2(1.); 
      /*
      color for final function gl_FragColor; 
      */
      vec4 baseColor = vec4(0.,0.,0.,1.);
      /*
      pulseMaker delivers some effect of pulsing
      used as offsetter nicelly moves/animates pattern from center to "plane frame" and aback (i z powrotem);
      */
      float pulseMaker = sin(uTime);
      /*
      ..............................................................
      resource
      https://www.youtube.com/watch?v=GgGBR4z8C9o
      */
    /*
    Circle
    */
    // vec2 originPointSetter = vec2(0.,0.);
    // float c = DrawCircle(uv, originPointSetter, .3, .02);
    // c -= DrawCircle(uv, vec2(0.), .1, .02);
    /*
    rectangle
    */
    // float shape = DrawRectangle(uv,.5, .5, 0.01);
    /*
    Distortion
    */
   float x = uv.x;
   float y = uv.y;
   
  //  float modificator = (x-.9) * (x+.9);
  //  modificator = modificator * modificator;
  //  y -= modificator;
    float modificator = sin(uTime + x * 4.) * .1;
    y -= modificator;
    
    float blur = remap( -1., 1., .01, .25, x );
    /*
    
    */
   /*
   inputs for DrawQuadrangle function: coord, width, height, ...
   */
   float newShape = DrawQuadrangle(vec2(x,y),1., .2, blur, 1., 1.);
    /*
    "baseColor" returns purple; "c" returns white ring and the rest is black 
    ima
    */
   float s1 = smoothstep(-.5,-.45, x);
  //  float s2 = 1.-smoothstep(.45,.5, x);
  //  float s2 = smoothstep(.5,.45, x);
   float s2 = smoothstep(.45,.50, x);
   float s3 = smoothstep(.05, 0., abs(x));



    baseColor.rb = vec2(1.);
    // baseColor *=s1;
    baseColor *=s3;

    // baseColor *= newShape;

    gl_FragColor = vec4(vec4(baseColor));

  }
  `
);

export { DomainDistortionShaderMaterial };

/*
      alternative coordinate system
       vec2 pixelCoordinate = (gl_FragCoord.xy - vec2(uResolutionX, uResolutionY)) * 2. - 1.; // ! * vec2(2./2.) - vec2(1.,1.);

    if(uResolutionX > uResolutionY ) pixelCoordinate.x *= uResolutionX/uResolutionY; else pixelCoordinate.y *= uResolutionY/uResolutionX;
      */

/*
    desktop: central jajo ;
    mobile: bottom/right jajo;
    */
//  vec2 pixelCoordinate = gl_FragCoord.xy / vec2(uResolutionX, uResolutionY);
//  pixelCoordinate *=2.;
//  pixelCoordinate -=1.;
// vec2 pixelCoordinate = (gl_FragCoord.xy * 2. - vec2(uResolutionX, uResolutionY)) / min(vec2(uResolutionX, uResolutionY), uResolutionY);
// vec2 pixelCoordinate = (gl_FragCoord.xy * 2. - vec2(uResolutionX, uResolutionY)) / min( uResolutionX, uResolutionY);
/*
    ...all is rounded by in mobile circle goes bottom left
    vec2 pixelCoordinate = (gl_FragCoord.xy * 2. - vec2(uResolutionX, uResolutionY)) / uResolutionY;
    vec2 landscape = (gl_FragCoord.xy * 2. - vec2(uResolutionX, uResolutionY)) / uResolutionY;
    vec2 portrait = pixelCoordinate = (gl_FragCoord.xy * 2. - vec2(uResolutionX, uResolutionY)) / uResolutionX;

    if(uResolutionX > uResolutionY ) pixelCoordinate = landscape; else pixelCoordinate = portrait;
    */
