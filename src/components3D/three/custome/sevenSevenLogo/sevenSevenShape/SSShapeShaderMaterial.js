import { shaderMaterial } from '@react-three/drei';
import glsl from 'babel-plugin-glsl/macro';
import * as THREE from 'three';

const SSShapeShaderMaterial = shaderMaterial(
  /*
   _____Uniforms
 */
  {
    uColor: new THREE.Color([1.0, 0.0, 1.0]),
    uTime: 0.0,
    uWidth: 0.0,
  },

  /*
   _____Vertex Shader
 */

  glsl`

  varying vec2 vUv;
  varying vec3 vPosition;
  varying vec2 vScreenCoordinates;
  varying vec3 vNormal; 

  
  void main(){
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);

    //___
    vUv = uv;
    vPosition = position;
    vNormal = normal; 
    /*
    What is "vScreenCoordinates"?
    This is the way we get "screen coordinates" within Vertex Shader (remember that shader is just a small application with some default outputs)... these coordinates are given for free!!! just use them!... using "gl_Position.w" a normalized version is created...yet I don't know what that ".w" is... 
    so wa are talking about "screen space" generated by all this matrices that take part in final result of gl_Position!!!
    moreover, it allowes to achieve some effects without 'postprocessing'
    */
    vScreenCoordinates = gl_Position.xy/gl_Position.w;
  }
  
  `,

  /*
   _____Fragment Shader
 */

  glsl`

  varying vec2 vUv;
  varying vec3 vPosition;
  varying vec2 vScreenCoordinates;
  varying vec3 vNormal; 

  uniform float uTime;
  uniform float uWidth;

  /*
  ..........................Noise....................
  */
 float threshold(float edge0, float edge1, float x){
   return clamp((x-edge0) / (edge1-edge0), 0., 1.);
 }

 float hash(vec3 p){
   p=fract(p*0.3183099+.1);
   p*=17.;
   return fract(p.x*p.y*p.z*(p.x+p.y+p.z));
 }

 float noise(in vec3 x){
   vec3 i = floor(x);
   vec3 f = fract(x);
   f=f*f*(3.-2.*f);

   return mix(mix(mix(hash(i+vec3(0.,0.,0.)),
              hash(i+vec3(1.,0.,0.)), f.x),
              mix(hash(i+vec3(0.,1.,0.)),
              hash(i+vec3(1.,1.,0.)), f.x),f.y),
              mix(mix(hash(i+vec3(0.,0.,1.)),
              hash(i+vec3(1.,0.,1.)), f.x),
              mix(hash(i+vec3(0.,1.,1.)),
              hash(i+vec3(1.,1.,1.)), f.x),f.y),f.z);
              
 }

 float rand(float n) {return fract(sin(n)* 43758.5453123);}
  float noise(float p){
    float fl = floor(p);
    float fc = fract(p);
    return mix(rand(fl), rand(fl + 1.), fc);
  }
  /*
    ....................Noise  End....................
  */

  void main (){
      /*
      _____lets work with "light"!!! to do this we need "normal" / default argument converted to "varying";
      _____using "*0.5+0.5" we avoid "100% dark side of the moon" => I guess that normalizing "normals" range of values is (-1,1) and this formula changes it to (0,1) => it also means that we don't loose information / data as all values below 0 are invisible...
       */
      float light = dot(vNormal, normalize(vec3(1.)))*0.5+0.5;
      /*
      _____Basic coloring of shader; no need to comments this line as only the one is red
      */
      gl_FragColor = vec4(vUv, 1.,1.);
      gl_FragColor = vec4(vPosition,1.);
    /*
    In that case we are rendering "Screen Space Coordinates" not object space coordinates => when we scroll object increase but colors remain "unchanged" i.e. it looks as if they were stick to the screen
    */
      gl_FragColor = vec4(vScreenCoordinates,0.,1.);
    /* 
    In that case we are rendering using "light coordinates" we got above from normal
    */
      gl_FragColor = vec4(vec3(light),1.);
    /* 
    In that case we are creating strokes / lines
    */
      float stroke = cos(vScreenCoordinates.x*uWidth*50.);
      gl_FragColor = vec4(vec3(stroke), 1.);

    /*
    noise variations
    */
      float smallNoise = noise(500.*vec3(vScreenCoordinates, 1.));
      float bigNoise = noise(5.*vec3(vScreenCoordinates, 1.));
      stroke += (smallNoise*2. - 1.) + (bigNoise*2. - 1.) + light;
    //   gl_FragColor = vec4(vec3(stroke), 1.);




    /*
    noise test
    */
    // gl_FragColor = vec4(vec3(noise(100.*vec3(vScreenCoordinates, 1.))),1.);




  }
  
  `
);
export { SSShapeShaderMaterial };
